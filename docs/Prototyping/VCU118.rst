Running a Design on VCU118
==========================

Basic VCU118 Design
-------------------

기본 Xilinx VCU118 하네스는 UART, SPI SDCard 및 DDR 백업 메모리를 설정하도록 구성되어 있습니다. 이를 통해 SDCard에서 RISC-V Linux를 실행하면서 터미널을 UART를 통해 VCU118에 연결된 호스트 머신으로 전송할 수 있습니다. 이 디자인을 확장하려면, 자신만의 Chipyard 구성을 만들고 ``fpga/src/main/scala/vcu118/Configs.scala`` 에 있는 ``WithVCU118Tweaks`` 를 추가할 수 있습니다. 이 구성 조각을 추가하면 UART, SPI SDCard 및 DDR 백업 메모리가 Chipyard 디자인/구성에 연결되고 활성화됩니다.

.. literalinclude:: ../../fpga/src/main/scala/vcu118/Configs.scala
    :language: scala
    :start-after: DOC include start: AbstractVCU118 and Rocket
    :end-before: DOC include end: AbstractVCU118 and Rocket

Brief Implementation Description + More Complicated Designs
-----------------------------------------------------------

VCU118 디자인의 기본은 외부 IO를 Chipyard 디자인에 연결하기 위한 특수 테스트 하네스를 만드는 것에 있습니다. 이는 기본 VCU118 FPGA 타겟에서 ``VCU118TestHarness`` 를 사용하여 이루어집니다. ``VCU118TestHarness`` (``fpga/src/main/scala/vcu118/TestHarness.scala`` 에 위치)는 VCU118 외부 IO에 연결되는 ``Overlays`` 를 사용합니다. 일반적으로 ``Overlays`` 는 ``ChipTop`` (파일에서 ``topDesign``으로 표시됨)에서 IO를 가져와 "배치"하고 외부 IO에 연결하며 필요한 Vivado 부수 자료를 생성합니다. 예를 들어, 아래는 ``io_uart_bb`` 라는 IO 입력을 사용하여 디자인에 UART ``Overlay`` 를 "배치"하는 예시입니다.

.. literalinclude:: ../../fpga/src/main/scala/vcu118/TestHarness.scala
    :language: scala
    :start-after: DOC include start: UartOverlay
    :end-before: DOC include end: UartOverlay

여기서 ``UARTOverlayKey``가 참조되고 UART에 연결하기 위한 필수 연결(및 부수 자료)을 "배치"하는 데 사용됩니다. ``UARTDesignInput`` 은 ``ChipTop`` / ``topDesign`` 에서 ``Overlay`` 로 UART IO를 전달하는 데 사용됩니다. ``BundleBridgeSource`` 는 ``LazyModule`` 범위에서 정의된 영광된 와이어로 볼 수 있습니다. 이 패턴은 테스트 하네스의 다른 모든 ``Overlays`` 에도 유사합니다. 이들은 "배치"되어야 하며 입력(IOs, 매개변수) 세트를 제공받아야 합니다. 이 패턴의 주요 예외는 FPGA의 클록 생성을 위해 사용되는 ``Overlay`` 입니다.

.. literalinclude:: ../../fpga/src/main/scala/vcu118/TestHarness.scala
    :language: scala
    :start-after: DOC include start: ClockOverlay
    :end-before: DOC include end: ClockOverlay

세부 사항을 생략하고 설명하면, 클록 오버레이는 하네스에 배치되며 PLL 노드( ``harnessSysPLL`` )가 ``ClockSinkNodes`` 에 의해 지정된 필요한 클록을 생성합니다. 사용의 편의를 위해, 기본 FPGA 디자인의 클록 주파수를 변경하려면 ``FPGAFrequencyKey``  를 변경할 수 있습니다.

하네스가 생성된 후, ``BundleBridgeSource`` 는 ``ChipTop`` IO에 연결되어야 합니다. 이는 하네스 바인더와 io 바인더로 수행됩니다 ( ``fpga/src/main/scala/vcu118/HarnessBinders.scala`` 및 ``fpga/src/main/scala/vcu118/IOBinders.scala`` 참조). 하네스 바인더와 io 바인더에 대한 자세한 내용은 :ref:`Customization/IOBinders:IOBinders and HarnessBinders` 를 참조하십시오.

.. Note:: 새로운 테스트 하네스가 생성되거나 구성 변경, 구성 패키지 변경 등이 발생할 때마다 make 호출을 수정해야 한다는 점을 기억하십시오. 예를 들어, ``make SUB_PROJECT=vcu118 CONFIG=MyNewVCU118Config CONFIG_PACKAGE=this.is.my.scala.package bitstream`` 와 같이 수정해야 합니다. 다양한 make 변수에 대한 정보는 :ref:`Prototyping/General:Generating a Bitstream` 을 참조하십시오.

Running Linux on VCU118 Designs
-------------------------------

위에서 언급했듯이, 기본 VCU118 하네스는 UART와 SPI SDCard로 설정되어 있습니다. 이들은 DUT와 상호작용(UART 사용)하고 Linux를 로드(SDCard 사용)하는 데 사용됩니다. 다음 단계는 프로토타입 플랫폼에서 buildroot Linux를 빌드하고 실행하는 방법을 설명합니다.

Building Linux with FireMarshal
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

현재 프로토타입은 블록 디바이스가 설정되어 있지 않기 때문에, 우리는 rootfs를 바이너리에 내장한 Linux를 빌드합니다 (다른 말로 "initramfs" 또는 "nodisk" 버전의 Linux). 이러한 유형의 Linux 바이너리를 쉽게 빌드하기 위해 FireMarshal 플랫폼을 사용합니다 (초기 설정에 대한 자세한 내용은 :ref:`fire-marshal` 을 참조하십시오).

1. FireMarshal을 설정하십시오 (초기 설정에 대한 내용은 :ref:`fire-marshal` 을 참조하십시오).
2. 기본적으로 FireMarshal은 FireSim과 함께 작동하도록 설정되어 있습니다. 대신, 우리는 프로토타입 플랫폼을 목표로 합니다. 이는 ``marshal-config.yaml`` 을 사용하여 FireMarshal "보드"를 "firechip"에서 "prototype"으로 전환하여 수행됩니다:

.. code-block:: shell

    # 이미 `marshal-config.yaml` 파일이 설정되어 있지 않다고 가정합니다.
    echo "board-dir : 'boards/prototype'" > $PATH_TO_FIREMARSHAL/marshal-config.yaml

.. Note:: 환경 변수 등을 통해 보드를 다르게 설정하는 방법에 대해서는 FireMarshal 문서를 참조하십시오.

3. 다음으로, FireMarshal에서 ``nodisk`` 옵션 플래그를 사용하여 워크로드(예: buildroot Linux)를 빌드하십시오. 이 단계에서는 기본 ``br-base.json`` 워크로드를 사용하는 것으로 가정합니다. 이 워크로드는 기본 UART 드라이버 외에도 GPIO 및 SPI 드라이버에 대한 기본 지원을 포함하고 있습니다. 다른 워크로드에서 이를 기반으로 빌드할 수 있습니다 (워크로드 상속에 대한 자세한 내용은 FireMarshal 문서를 참조하십시오).

.. code-block:: shell

    ./marshal -v -d build br-base.json # 여기서 -d는 --nodisk 또는 initramfs를 나타냅니다.

.. Note:: "보드" FireMarshal 기능을 사용하면 ``br-base.json`` 워크로드 사양에 의존하는 모든 자식 워크로드가 FireChip 플랫폼이 아닌 "prototype" 플랫폼을 타겟팅할 수 있습니다. 따라서 "보드"만 변경하여 프로토타입 플랫폼에서 기존 워크로드를 재사용할 수 있습니다!

4. 적절한 바이너리를 생성하는 마지막 단계는 이를 평탄화하는 것입니다. 이는 FireMarshal의 ``install`` 기능을 사용하여 이전에 빌드된 Linux 바이너리(``br-base-bin-nodisk`` )에서 ``$PATH_TO_FIREMARSHAL/images`` 디렉터리에 ``*-flat`` 바이너리(이 경우 ``br-base-bin-nodisk-flat`` )를 생성하여 수행됩니다.

.. code-block:: shell

   ./marshal -v -d install -t prototype br-base.json

Setting up the SDCard
~~~~~~~~~~~~~~~~~~~~~

이 지침은 두 개의 파티션을 사용하여 Linux 및 기타 파일을 로드할 수 있는 여분의 uSDCard가 있으며 Linux와 ``sudo`` 권한 및 ``gdisk`` 를 사용하는 것으로 가정합니다. 그러나 Mac에서는 유사한 절차를 따를 수 있습니다 (``gpt`` 또는 다른 유사한 프로그램 사용).

1. ``gdisk`` 를 사용하여 카드의 GPT를 지우십시오. 전문가 메뉴(‘x’로 열고 ‘m’으로 닫음)에서 `z` 명령을 사용하여 모든 것을 제거하십시오. 나머지 지침에서는 SDCard 경로를 ``/dev/sdc`` 로 가정합니다 (SDCard 경로를 자신의 경로로 교체하십시오).

.. code-block:: shell

    sudo gdisk /dev/sdc

2. `o` 를 사용하여 새로운 GPT를 생성하십시오. 모든 프롬프트에 예를 선택하십시오.

3. VCU118 부트롬은 SDCard의 섹터 34에 위치한 Linux 바이너리를 메모리에 로드할 것으로 가정합니다. 섹터 `34` 에 쓸 수 있도록 기본 파티션 정렬을 `1` 로 변경하십시오. 전문가 메뉴에서 `l` 명령을 사용하여 수행합니다 (전문가 메뉴는 'x'로 열고 'm'으로 닫습니다).

4. Linux 바이너리를 저장할 512MiB 파티션을 생성하십시오 (이 크기는 더 작을 수 있지만 Linux 바이너리 크기보다는 커야 합니다). `n` 을 사용하고, 파티션 번호 1을 선택하고 섹터 34를 선택한 후 크기 `+1048576` (512MiB

에 해당)을 입력하십시오. 타입으로 `apfs` 타입을 검색하여 주어진 16진수를 사용하십시오.

5. 나머지 SDCard 공간을 사용하여 다른 파일을 저장할 두 번째 파티션을 생성하십시오. `n` 을 사용하고, 파티션 번호, 시작 섹터 및 전체 크기에 대한 기본값을 사용하십시오 (두 번째 파티션을 SDCard의 나머지 공간으로 확장하십시오). 타입으로 `hfs` 를 검색하여 주어진 16진수를 사용하십시오.

6. `w` 를 사용하여 변경 사항을 기록하십시오.

7. 두 번째 파티션에 파일 시스템을 설정하십시오. ``/dev/sdc2`` 가 두 번째 파티션을 가리킨다는 점을 유의하십시오. 다음 명령을 사용하십시오:

.. code-block:: shell

    sudo mkfs.hfs -v "PrototypeData" /dev/sdc2

Transfer and Run Linux from the SDCard
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Linux 부팅 바이너리와 SDCard가 올바르게 설정된 후 (1번째 파티션이 섹터 34에 위치), 바이너리를 1번째 SDCard 파티션에 전송할 수 있습니다. 이 예제에서는 FireMarshal에서 ``br-base-bin-nodisk-flat`` 을 생성했으며 이를 ``dd`` 를 사용하여 로드할 것입니다. ``sdc1`` 이 1번째 파티션을 가리킨다는 점을 기억하십시오 (``sdc`` 를 자신의 SDCard 경로로 변경하십시오).

.. code-block:: shell

    sudo dd if=$PATH_TO_FIREMARSHAL/br-base-bin-nodisk-flat of=/dev/sdc1

두 번째 파티션에 파일을 추가하려면 지금 추가할 수도 있습니다.

SDCard에 Linux 및 잠재적으로 다른 파일을 로드한 후, FPGA를 프로그래밍하고 SDCard를 삽입하십시오. UART 콘솔을 통해 Linux와 상호작용하려면 ``screen`` 과 같은 프로그램을 사용하여 시리얼 포트에 연결할 수 있습니다 (이 경우 ``ttyUSB1`` 이라 불림):

.. code-block:: shell

   screen -S FPGA_UART_CONSOLE /dev/ttyUSB1 115200

연결되면 바이너리가 로드되는 것과 Linux 출력이 표시되어야 합니다 (일부 경우에는 DUT를 리셋해야 할 수도 있습니다). 'root'로 로그인하고 비밀번호는 'fpga'입니다.
